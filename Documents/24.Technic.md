### Technic

## Pessimistic lock
Pessimistic lock là cách tiếp cận "bi quan" - giả định xung đột sẽ xảy ra, nên khóa tài nguyên ngay trước khi truy cập và chỉ mở khóa sau khi hoàn thành.

- Lỗi: Race condition
- Giải pháp: Pessimistic lock


Câu lệnh SQL lock 
```sql Ecommerce/ecom/src/routes/order/order.repo.ts
Khóa record với id là 1,2,3
SELECT * FROM "SKU" WHERE id IN 1,2,3 FOR UPDATE

Khóa record với id = 1
SELECT * FROM "SKU" WHERE id = 1 FOR UPDATE
```

## Optimistic lock
Optimistic lock (khóa lạc quan) là cách tiếp cận "lạc quan" - giả định xung đột hiếm khi xảy ra, nên không khóa tài nguyên khi đọc. Thay vào đó, `kiểm tra xem dữ liệu có bị thay đổi không trước khi cập nhật`.

- Cách hoạt động
Nguyên lý: Mỗi bản ghi có một version hoặc timestamp. Khi cập nhật, kiểm tra version có khớp không. Nếu không khớp = có người khác đã sửa = conflict.

- Lợi dụng query các giá trị không trùng khớp nên sẽ trả về lỗi VersionConflictException thì người dùng sẽ retry api đó.
```ts
for (const item of cartItems) {
    await tx.sKU
        .update({
        where: {
            id: item.sku.id,
            updatedAt: item.sku.updatedAt, // Sử dụng optimistic lock để tránh tình trạng oversell . Đảm bảo không có ai cập nhật SKU trong khi chúng ta đang xử lý
            stock: { gte: item.quantity }, // Đảm bảo số lượng tồn kho đủ để trừ
        },
        data: {
            stock: {
            decrement: item.quantity,
            },
        },
        })
        .catch((e) => {
        if (isNotFoundPrismaError(e)) {
            throw VersionConflictException
        }
        throw e
        })
    }
```


## Redlock
- Red lock là một thuật toán phân tán để triển khai khóa phân tán (distributed lock) trên Redis, được thiết kế bởi Salvatore Sanfilippo - tác giả của Redis.

Cách hoạt động:
1. Sử dụng nhiều Redis master nodes độc lập (thường là 5 nodes)
2. Client cố gắng lấy lock trên tất cả các nodes
3. Chỉ được coi là thành công nếu lấy được lock trên đa số nodes (ví dụ: 3/5)
4. Tổng thời gian lấy lock phải nhỏ hơn thời gian TTL của lock

Ưu điểm:
1. Tăng độ tin cậy so với single Redis instance
2. Tránh single point of failure


Hạn chế:
1. Phức tạp hơn trong triển khai và vận hành
2. Một số chuyên gia (như Martin Kleppmann) đã chỉ ra những vấn đề về tính an toàn trong một số trường hợp edge cases