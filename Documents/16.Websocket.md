### [Websocket](https://docs.nestjs.com/websockets/gateways)


- Gửi request `send-message` nhưng nhận thì phải listen `receive-message`
```ts
@WebSocketGateway()
export class ChatGateway {
  @WebSocketServer()
  server: Server

  // Listen for 'send-message' events from clients
  @SubscribeMessage('send-message')
  handleEvent(@MessageBody() data: { name: string }): { name: string } {
    // Emit 'receive-message' event to all connected clients
    this.server.emit('receive-message', {
      data: `Hello ${data.name}`,
    })
    return data
  }
}

```

- `namespace` trong websocket như route trong nestjs
```ts
@WebSocketGateway({
  namespace: 'payment',
})
```
- `Custom Websocket adapter`: Có thể config port, cors chung cho WebsocketAdapter

```ts websocket.adapter.ts 
import { IoAdapter } from '@nestjs/platform-socket.io'
import { ServerOptions, Server } from 'socket.io'

export class WebsocketAdapter extends IoAdapter {
  createIOServer(port: number, options?: ServerOptions) {

    const server: Server = super.createIOServer(port, {
      ...options,
      cors: {
        origin: '*',
        credentials: true,
      },
    })
    return server
  }
}
```
```ts main.ts
app.useWebSocketAdapter(new WebsocketAdapter(app))
```


- Lifecycle hooks  
  - OnGatewayInit
  - OnGatewayConnection
  - OnGatewayDisconnect



- Bắn sự kiện khi user thanh toán thành công
  - Cách bắn socket thông thường
```ts
websockets.forEach((ws) => {
  this.server.to(ws.id).emit('status-payment', {
    status: 'success',
  })
})
```
  - Cách bắn socket qua room [Link](https://socket.io/docs/v4/rooms/)
Với những client nào cũng 1 room thì sẽ đều trong 1 room thì đều nhận được sự kiện `status-payment`
```ts
// websocket.adapter.ts
await socket.join(generateRoomUserId(userId))

// payment.service.ts
this.server.to(generateRoomUserId(userId)).emit('status-payment', {
  status: 'success',
})
```

- With multiple Socket.IO servers
  - `multiple Socket.IO server` là kiến trúc có nhiều server Socket.IO chạy đồng thời, cùng phục vụ các kết nối real-time cho ứng dụng của bạn.
```ts
Client A kết nối → Server 1
Client B kết nối → Server 2

// Khi Client A emit event, Client B không nhận được
// vì họ ở 2 server khác nhau!
// Chạy 2 tiến trình khác nhau, mà các tiến trình 1 sẽ không share tiến trình 2
```
  - Vậy khi sử dụng `multiple server` thì phải sử dụng `redis adapter` để có thể share các server, socket ở các tiến trình. 
