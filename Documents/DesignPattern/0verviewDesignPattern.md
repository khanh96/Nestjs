[Link overview design pattern](https://levelup.gitconnected.com/how-to-scale-like-a-senior-engineer-servers-dbs-lbs-spofs-78a8e624955b)

- (Servers, DBs, LBs, SPOFs)

### Load Balancer
  + **Round Robin algorithm:** Thuật toán này sẽ phân phối các request đến các server. VD: resquest 1 -> server 1, resquest 2 -> server 2, resquest 3 -> server 3, Giả sử server 3 là server cuối cùng thì request tiếp thêm sẽ lại về server 1. Cứ như thể tạo thành một vòng tròn. Cách này tốt khi các máy chủ có **cấu hình như nhau.** Và các server đều **free** thì đấy sẽ là lựa chọn tốt nhất.
  + **Least connections algorihm:** Thuật toán này sẽ tìm ra server **có lưu lượng request từ client đến server đó ít nhất**. VD: server1: 10, server2: 9. server3: 30. Vậy request đến LB sẽ chuyển hướng đến server2: (9 + 1) vì nó có ít request đến nhất trong tất cả các server. Cách này tốt nhất khi ứng dụng có **phiên làm việc độ dài của từng request là khác nhau**.
  + **Least response time algorihm:** Thuật toán này **thời gian phản hồi ngắn nhất** và **tập trung vào phản hồi.** Có nghĩa là nhiều connect đến server nào nhất thì có khả năng phản hồi cao nhất VD: Server1: High - 30, Server1: Low - 10 , Server1: Medium - 20. Sau khi đi quả cả 3 server thì có Server1 là server được nhiều request và phản hồi nhanh nhất nên sẽ chọn server1. Cách này tốt nhất khi ứng dụng có **cung cấp thời gian phản hổi nhanh nhất** và **các máy chủ khác nhau với khả năng khác nhau**.
  + **IP hash algorihm:** Thuật toàn này xác định server nào nhận được dựa **trên hàm băm địa chỉ IP của máy khách**. Điều này hữu ích khi muốn Client liên tục kết nối tới 1 máy chủ server nhất định. Hoạt động. Client 1 có địa chỉ (ip:123.456.789) -> LB (sẽ băm địa chỉ ra) => Server 2: (Lưu IP hash của client 1). Vậy bất cứ request nào của (ip:123.456.789) sẽ đều tới server 2.
  + **Weighted Algorithms:** Thuật toán này kết nối **vòng tròn có trọng số or kết nối danh sách có trọng sô.** Trong đó sẽ dự trên số liệu về **dung lượng và hiệu suất**. VD: Server1: 16g, Server2: 32g, Server3: 64g, LB sẽ tính lưu lượng và trọng số sẽ chuyển lượng lưu lượng kết nối đến Server3 trước rồi tiếp đến Server2 và còn 1 ít lưu lượng là đến Server1.
  + **Geographical Algorithms:** Thuật toán này dựa trên **bề mặt vật lý của client và server**. VD: client1: Asia, client2: Euro . server1: USA, server2: Asia. Thì những request từ các client1 đến LB. LB sẽ ưu tiên các request này đến server2 về mặt địa lý Client1 gần với Server2.
  + **Consistent Algorithms:** Thuật toán băm nhất quán để **phân phối dữ liệu trên nhiều nút khác nhau**. Chúng ta có một hàm băm trong LB và tròn nối các server của chúng ta thành 1 vòng tròn. VD: serve1 -> server2 -> server3 -> lặp lại. Khi một request từ client -> server giả sử có ip (ip:123.456.789) -> LB (sẽ băm địa chỉ ra) và sẽ tìm đến diểm nối gần nhất giữa các server kết nối với nhau như 1 vòng tròn trên. Giả sử gần ở giữa kết nối server2 và server3 nhưng lại gần server3 hơn thì request đó sẽ tới server3. Các này giúp cho request nào có cùng IP đều tới 1 server như **IP hash algorihm:**
- Chúng ra nói đến việc tại sao LB có thể biết được server nào còn hoạt động thì mới chuyển lưu lượng đến server đó. Đó chính là **Health check**. Hầu hết các LB đều có **Health check** sẽ có kiểm tra các server có trực tuyến hay không? Cái nào không trực tuyến có nghĩa là đã chết và sẽ không chuyển lưu lượng request đến server đó nữa.

### Single Point Of Failure (SPOF) 
- Có nghĩa là Điểm lỗi đơn. một khi lỗi ở LB or DB thì tất cả hệ thống sẽ chết dẫn đến ảnh hưởng đến người dùng.
- Giải pháp:
  + **Redundancy** (Sự dư thừa): Thêm 1 LB vậy ta có 2LB để khi nào 1LB chết thì các lưu lượng request vẫn có thể tiếp tục chạy thông qua LB khác được. Và khi LB đó hoạt động trở lại thì ta sẽ chuyển 50% lưu lượng đến LB đó.
  + **Health checks & monitoring**: Liên tục kiểm tra tình trạng của LB và server. Một khi có 1 LB chết thì sẽ không chuyển lưu lượng request đến nó cho đến khi nó hoạt động trở lại.  
  + **Self-healing systems** (Hệ thống tự phục hồi): Chúng ta sẽ theo dõi LB của mình. Và một khi mà LB đó chết thì sẽ lập tự loại bỏ LB đó và thay LB mới và chỗ đó. Để các lưu lượng request vẫn có thể tiếp tục chạy.