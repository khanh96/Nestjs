# Nên viết Unit Test cho file nào ở dự án Ecom NestJs?

Ở chương Testing cơ bản, mình đã hướng dẫn viết Unit Test cho repository, service, controller, function tiện ích...

Nhưng trong một dự án thực tế, thời gian coding là có hạn, không nên viết Unit Test cho tất cả các file.

Đảm bảo **100% coverage** là không thực tế và không cần thiết.

Nên ưu tiên Unit test logic nghiệp vụ quan trọng

Vậy nên cần nhìn vào source thực tế mà chọn file để viết unit test.

Ví dụ trong auth routes

## Không cần viết unit test cho

`auth.module.ts`

Không cần viết unit test cho file này vì nó chỉ để cấu hình module, không có logic nghiệp vụ.

`auth.controller.ts`

- Không có business logic
- Chỉ nhận request → gọi service → trả response
- Logic đã được test ở service layer

`auth.repo.ts`

- Chỉ là wrapper của Prisma
- Tốn thời gian, ít giá trị

`auth.model.ts`

- Chỉ chứa Zod schemas và type definitions
- Logic validation đã được Zod xử lý
- Nếu muốn test, nên test ở service level khi dùng schemas này

`auth.dto.ts`

- Chỉ là wrapper của Zod schemas thành DTOs cho NestJS
- Không có logic riêng
- Validation được test tự động qua integration tests

`auth.error.ts`

- Chỉ là constants/factory cho exceptions
- Không có logic phức tạp
- Được test gián tiếp qua service tests

## Nên tập trung Unit test vào

Các file service (`auth.service.ts`, `google.service.ts`)


## Có thể bạn chưa biết

```ts
describe('AuthService', () => {
  describe('createUser', () => {
    it('should create user successfully', () => {})
  })
})
```

`-> AuthService createUser should create user successfully`

Thực hành:

Ecommerce/ecom/src/routes/auth/auth.service.spec.ts

- Setup chạy test các file
```json // package.json
"jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts",
      "tsx",
      "jsx"
    ],
    "rootDir": ".", // chạy từ root
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/src/$1",
      "^generated/(.*)$": "<rootDir>/generated/$1",
      "^emails/(.*)$": "<rootDir>/emails/$1"
    },
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)sx?$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
```

CLI: [Link](https://jestjs.io/docs/cli#using-with-package-manager)
-  Test toàn bộ test case trong file file.spec.ts
```bash
npm run test file.spec.ts
```

- Test group test case verifyVerificationCode
```bash 
npm run test auth.service.spec.ts -- -t="verifyVerificationCode"
```

- Test test case should validate verification code successfully
```bash Test test case verifyVerificationCode
npm run test auth.service.spec.ts -- -t="should validate verification code successfully"
```

```ts 
describe('verifyVerificationCode', () => {
    it('should validate verification code successfully', async () => {
      const mockVerificationCode = {
        id: 1,
        email: 'test1@example.com',
        type: VerificationCode.REGISTER,
        code: '123456',
        expiresAt: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes from now
        createdAt: new Date(),
      }
      // Mock the repository method
      mockAuthRepository.findUniqueVerificationCode.mockResolvedValue(mockVerificationCode)

      // Use bracket notation to access private method
      const result = await authService['verifyVerificationCode']({
        email: 'test@example.com',
        code: '123456',
        type: VerificationCode.REGISTER,
      })

      // Assert the result
      expect(result).toEqual(mockVerificationCode)
      // Verify that the repository method was called with correct parameters
      expect(mockAuthRepository.findUniqueVerificationCode).toHaveBeenCalledWith({
        email: 'test@example.com',
        code: '123456',
        type: VerificationCode.REGISTER,
      })
    })
  })
```
